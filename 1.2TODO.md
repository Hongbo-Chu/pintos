<!--
 * @Author: your name
 * @Date: 2021-10-25 22:18:16
 * @LastEditTime: 2021-10-27 14:58:29
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /pintos/1.2TODO.md
-->
#1.2TODO
##一. 将就绪队列改为优先队列<font color = BLUE>(pass: alarm_priority)<font>
###以下三种情况会用到
    1. thread_unblock

    2. init_thread

    3. thread_yield

###实现思路：
    1.使用`list_insert_ordered()`函数分别修改上面的三个函数？？
    2.实现优先级比较函数`thread_cmp_priority()`
##二. 抢占式调度<font color = BLUE>(pass: priority-change; priority-preemept)<font>
在设置一个线程优先级要立即重新考虑所有线程执行顺序， 重新安排执行顺序。
###解决方案：
    在create和set_priority后直接调用`thread_yield()`添加到就绪队列中（此时就绪队列已经修改为优先队列）

##三.优先级捐赠<font color = BLUE>(pass: priority-donate-*)<font>
1.  priority-donate-one
    1.  测试点：由于lock的原因，线程不能按照设定的优先级顺序执行，所以要通过线程捐赠使线程可以按照优先级执行。
    2.  实现思路：当一个线程得到锁（小于零的信号量）时，如果锁的主人(holder)的优先级低于自己，则提高它的优先级。然后在那个线程释放掉锁之前，再改回来
    ```c++
    struct lock 
  {
    struct thread *holder;      /* Thread holding lock (for debugging). */
    struct semaphore semaphore; /* Binary semaphore controlling access. */
  };
  ```
2.  priority-donte-multiple
