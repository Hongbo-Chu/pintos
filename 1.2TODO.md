<!--
 * @Author: your name
 * @Date: 2021-10-25 22:18:16
 * @LastEditTime: 2021-11-04 17:56:37
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /pintos/1.2TODO.md
-->
#1.2TODO
##一. 将就绪队列改为优先队列
<font color = RED>(pass: alarm_priority)</font>
###以下三种情况中存在需要修改的队列
    1. thread_unblock

    2. init_thread

    3. thread_yield

###实现思路：
1.  使用`list_insert_ordered()`函数分别修改上面的三个函数？？
2.  实现优先级比较函数`thread_cmp_priority()`
##二. 抢占式调度
<font color = RED>(pass: priority-change; priority-preemept)</font>
在设置一个线程优先级要立即重新考虑所有线程执行顺序， 重新安排执行顺序。
###解决方案：
在create和set_priority后直接调用`thread_yield()`添加到就绪队列中（此时就绪队列已经修改为优先队列）



##三.优先级捐赠
<font color = RED>(pass: priority-donate-*)
</font>
###priority-donate-one

 1.  测试点：由于lock的原因，线程不能按照设定的优先级顺序执行，所以要通过线程捐赠使线程可以按照优先级执行。
 2.  实现思路：当一个线程得到锁（小于零的信号量）时，如果锁的主人(holder)的优先级低于自己，则提高它的优先级。然后在那个线程释放掉锁之前，再改回来
```c++
    struct lock 
  {
    struct thread *holder;      /* Thread holding lock (for debugging). */
    struct semaphore semaphore; /* Binary semaphore controlling access. */
  };
```

###priority-donte-multiple
1.  测试点：多锁情况下优先级逻辑的正确性。
个人感觉对于这个测试程序，即使添加了priority-donate，他的运行顺序也是不变的，变的是.ck文件中输出的主程序的优先级
`(priority-donate-multiple) Main thread should have priority 33.  Actual priority: 33.`
1.  实现思路： 释放一个锁的时候， 将该锁的拥有者改为该线程被捐赠的第二优先级，若没有其余捐赠者， 则恢复原始优先级。 
###priority-donate-multiple2
   1. 测试点：这里依然测试的是多锁情况下优先级逻辑的正确性。
       1. 这次有无priority-donate程序的运行顺序就不一样了。
###priority-donate-nest：
<font color= GREEN>测试程序分析：</font>
    low:占有locks.a
    mid:占有locks.a+locks.b
    high:占有locks.b
    1.  测试点：优先级嵌套问题， 重点在于medium拥有的锁被low阻塞， 在这个前提下high再去获取medium的说阻塞的话， 优先级提升具有连环效应， 就是medium被提升了， 此时它被锁捆绑的low线程应该跟着一起提升。
    2.  实现思路：从实现的角度来说， 我们线程又需要加一个数据结构， 我们需要获取这个线程被锁于哪个线程


###priority-donate-sema:

##总结：
1.  在一个线程获取一个锁的时候， 如果拥有这个锁的线程优先级比自己低就提高它的优先级，并且如果这个锁还被别的锁锁着， 将会递归地捐赠优先级， 然后在这个线程释放掉这个锁之后恢复未捐赠逻辑下的优先级。

2. 如果一个线程被多个线程捐赠， 维持当前优先级为捐赠优先级中的最大值（acquire和release之时）。

3. 在对一个线程进行优先级设置的时候， 如果这个线程处于被捐赠状态， 则对original_priority进行设置， 然后如果设置的优先级大于当前优先级， 则改变当前优先级， 否则在捐赠状态取消的时候恢复original_priority。

4. 在释放锁对一个锁优先级有改变的时候应考虑其余被捐赠优先级和当前优先级。

##解决方案
* 结构体
    1. thread结构体添加{
       1. int own_priority//用于记录初始的优先级
       2. int given_priority//默认等于own_priority，要是有优先级捐赠的话就会改变。 
       3. struct list locks//用于记录当前线程都有哪些lock
       4. struct lock waitingFor//被锁在哪个线程
      }

   1.  lock结构体添加{
       1.  struct list donate//用于记录捐赠的历史
       2.  uint_16 maxP//用于记录捐赠的最大的优先级
      }
* 函数
    1. lock_acquire(){
          ++//判断条件（第一次和非第一次被调用），并嵌套捐赠
          ++//priority_donate()函数用于对lock_holder的优先级进行更改
          ++//
       } 
    2.  lock_release(){
          
        }
